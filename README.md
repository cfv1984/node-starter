# A decent node starter project

Current version: <small>v0.0.3</small>

## Introduction

So you're starting a new NodeJS project. You select a routing framework, a
rendering engine, a database and its respective node API, a code organization
scheme, an internal API of yours on top of it all, then look at the clock and
have already spent a day deciding how to go about your project.

This aims to prevent that. It's a starter project based around a blog project,
organized around resources, using a number of common tools and practices with
the end goal of hitting the ground running, having had most common choices
worked out for you.

## Includes

- Express
- Sequelize
- A JSX parser
- A resource centered architecture
- A sample project already set up and running (actually still in the works at
  the moment)
- DotEnv providing good default values for important environment variables

## Security

A couple security considerations have been taken into account: Upon first
install, an instance key and an admin password are autogenerated for you and
stored in an .env file.

The preinstall script will actually try and fill any important empty value
(ending in \_KEY or \_PASSWORD) with a random string. You need to take extra
care with this specific file, ideally having it copied from elsewhere as part of
the deployment process.

## Development

The starter suggests a directory structure that's heavily based around a
provided framework, although it can be sidestepped editing the express setup
file.

### Project layout

- `app/` _where you application itself lives_
  - `models/` _where you are supposed to put your resource models as well as any
    data-only entities_
  - `resources/` _where REST resources are defined_
  - `templates/` _where any templates your app uses live_
  - `views/` _where the actual views and view logic lives_
- `data/` _any mocks, assets, or related data files go here. The default dev env
  places an sqlite file here_
- `scripts/` _project wide general purpose scripts referenced from package.json
  live here_
- `.env` _this file defines environment variables if they aren't actually
  defined in the host_
- `package.json` you should already know what this is for

### The framework

The starter comes bundled with a simple framework that is centered around the
concepts of resources, views, models, and templates.

#### Resources

A resource represents an actual thing your application provides, in the REST
sense of the term. In the working example, there's a Posts resource providing
access to Blog Posts.

Each Resource can define a number of special methods, representing each of the
HTTP Verbs that can be applied to this resource:

- `Resource#detail` (mapping to for instance `GET posts/1`) means this resource
  will provide a single entity of some kind
- `Resource#list` (mapping to `GET posts`) implement this if you want to return
  a list of entities
- `Resource#create` (mapping to `POST posts`) this method is used when the
  application wants to add a new entity or run some process
- `Resource#replace` (mapping to `PUT posts/1`) lets you replace an existing
  entity with a provided, whole one
- `Resource#patch` (mapping to `PATCH posts/1`) means your resource can update
  parts of an existing entity
- `Resource#remove` (mapping to `DELETE posts/1`) provides the ability to delete
  an entity you used to provide, and
- `Resource#explain` (mapping to `OPTIONS posts` as well as `OPTIONS posts/1`)
  is used to either list all available actions for this resource, or to enable
  preflight requests

If any of this verbs return a promise, rendering will only take place after the
promise yields.

There's also some lifecycle hooks you can extend:

- `Resource#beforeRender()` _returns a promise which, if rejected, will cause an
  error to be thrown_
- `Resource#afterRender()` _returns a promise which, if rejected, will cause an
  error to be thrown_

Each `Resource` is required to have some `View` and `Model` objects passed to
its constructor like so:

```js
class SomeResource extends Resource {
	constructor(vars = {}) {
		// this is mandatory
		super(new SomeDataModel(), new SomeView());
		this.view.vars.params = vars.params;
	}
	// any verb handlers go down here
}
```

#### Views

A view controls what exactly is sent to the client. It can have variables
assigned to it via the `vars` object all views have, and it is capable of
rendering a template that is a required constructor parameter.

Default views use a JSX rendering engine but you can have your views render
through any mechanism you feel adequate by extending the `View#render` method.

Views **too** have a couple lifecycle methods, namely

- `View#beforeRender()` _returns a promise which, if rejected, will cause an
  error to be thrown_
- `View#afterRender()` _returns a promise which, if rejected, will cause an
  error to be thrown_

#### Models

Models control all aspects related to data manipulation. In the example
provided, a model is used to pull posts as well as for the admin interface
